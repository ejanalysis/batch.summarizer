#' x A matrix or data.frame to summarize, one row per site, one column per variable.
#' cols Specifies which colums of x should be summarized or used during summarization. A single string value 'all' as default to specify all, or a vector of colnames.
#' probs Vector of numeric values, fractions, to use as probabilities used in finding quantiles. Default is c(0,0.25,0.50,0.75,0.80,0.90,0.95,0.99,1)
#' na.rm Logical TRUE by default, specifying if na.rm should be used for sum(), mean(), and other functions.
#'
batch.summarize <- function(x, cols='all', wts=1, probs=c(0,0.25,0.50,0.75,0.80,0.90,0.95,0.99,1), threshold=80, threshnames='', na.rm=TRUE, rowfun.picked, colfun.picked) {

  # basic error checking
  if (missing(x)) {stop('x must be a matrix or data.frame to be analyzed')}
  if (cols[1]=='all') {cols <- colnames(x)}
  if (any(!(cols %in% colnames(x)))) {stop('invalid cols -- must be a vector of strings, all of which must be elements of names(x)')}
  if (!is.vector(probs) | !is.numeric(probs) | any(probs > 1) | any(probs < 0)) {stop('probs must be a numeric vector of fractions for quantile function')}

  # Specify summary metrics to calculate.
  # Provide a default set of summary metrics.
  # A later version could allow user to select from a list of functions, and eventually even specify custom functions perhaps, 
  # but offline work in R or a spreadsheet could provide that capability easily.
  
  # SUMMARY COLUMNS (a summary of each row):
  
  rowfuname <- vector()
  rowfun <- list()
  
  rowfuname[1]='Are any indicators at/above threshold'
  rowfun[[1]]=function(x, ...) {
print(threshnames)
    flagged(x[ , threshnames], cutoff=threshold, or.tied=TRUE, na.rm=na.rm)
  } 
  
  rowfuname[2]='Number of indicators at/above threshold'
  rowfun[[2]]=function(x, ...) {
    print(threshnames)
    cols.above.count( x[ , threshnames], cutoff=threshold, or.tied=TRUE, na.rm=na.rm )
    }
  
  # rowfunames[3]='Ratio to US pop avg'
  # rowfun[3]=function(x, usavgvalues, na.rm=TRUE) { x / usavgvalues } # that is not how the math will work - just a placeholder
  # need to identify those usavgvalues columns either here or when that is called
  
  #rowfunames[4]='Ratio to State pop avg'
  #rowfun[4]=function(x, stateavgvalues, na.rm=TRUE) { x / stateavgvalues } # that is not how the math will work - just a placeholder
  
  #num.EJ.at.above.threshold (was called num.EJ.80plus.calculated)
  #ratios.to.pop.usavg (1 col per relevant variable)
  #ratios.to.pop.region.avg (1 col per relevant variable)
  #ratios.to.pop.state.avg (1 col per relevant variable)
  #ratios.to.pop.county.avg?? (1 col per relevant variable)
  
  ############################################
  # SUMMARY ROWS (a summary of each column):
  ############################################

  #varname.batch (exactly as output by the batch tool)
  #varname.friendly (e.g., maybe 3 to 15 characters long)
  #varname.description (e.g., a complete phrase including units)
  #vartype (e.g. raw, uspctile, regionavg, pop, calculated, etc.)
  #varcategory (e.g., E, D, EJ)
  #quantiles including median- multiple rows at once for multiple cols at once
  #mean for flagged only?
  # note: Hmisc's describe() takes a df and returns printout of count, missing, length(unique), pctiles, and a table() of how many of each unique value there are.

  ############################################
  # THESE FUNCTIONS RETURN ONE ROW EACH:
  ############################################
  
  colfuname <- vector()
  colfun <- list()

  colfuname[1]='Sum'
  colfun[[1]]=function(x, ...) {colSums(x, na.rm=na.rm)}
  
  colfuname[2]='Count of sites'
  colfun[[2]]=function(x, ...) {apply(x, 2, FUN=function(y) length(y))}
  
  colfuname[3]='Number of unique values'
  colfun[[3]]=function(x, ...) {apply(x, 2, FUN=function(y) length(unique(y)))}
  
  colfuname[4]='Average site'
  colfun[[4]]=function(x, ...) {colMeans(x, na.rm=na.rm)}
  
  colfuname[5]='Average person'
  colfun[[5]]=function(x, ...) {wtd.colMeans(x, wts=wts, na.rm=na.rm)}
  
  colfuname[6]='Minimum'
  colfun[[6]]=function(x, ...) {colMins(x, na.rm=na.rm)}
  
  colfuname[7]='Maximum'
  colfun[[7]]=function(x, ...) {colMaxs(x, na.rm=na.rm)}
  
  colfuname[8]='Standard Deviation'
  colfun[[8]]=function(x, ...) {apply(x, 2, FUN=function(y) {sd(y, na.rm=na.rm)}) }

  ############################################
  # THESE FUNCTIONS RETURN MULTIPLE ROWS EACH:
  # THAT REQUIRES A DIFFERENT APPROACH TO POPULATING THE RESULTS VARIABLE
  # like using rbind instead of [i] <- 
  ############################################
  
# TESTING
#  colfuname[9]='Percentiles of sites'
#  colfun[[9]]=function(x, ...) {apply(x, 2, FUN=function(y) quantile(y , probs=probs, na.rm=na.rm))}
#  
#  colfuname[10]='Percentiles of people'
#  colfun[[10]]=function(x, ...) {wtd.quantile(x, weights=wts, probs=probs, na.rm=na.rm)}
  
  # colfuname[11]=''
  # colfun[[11]]=function(x, na.rm=TRUE) {}
  
  ############################################
  
  colfuns.count.all <- length(colfun)
  rowfuns.count.all <- length(rowfun)

  # for now, just pick all of them by default. later allow user to select perhaps.
  if (colfun.picked=='all') {
      colfun.picked= rep(TRUE, colfuns.count.all)  
      }
  if (rowfun.picked=='all') {
    rowfun.picked= rep(TRUE, rowfuns.count.all) 
    }
  
  colfuns.count.picked <- sum(colfun.picked)
  rowfuns.count.picked <- sum(rowfun.picked)
  
  # preallocate space to store summary stats on only those picked
  summary.rows <- matrix(NA, nrow=colfuns.count.picked, ncol=ncol(x)) # rows with summary stats summarizing all the columns. This will hold 1 row per summary stat, and same # cols as original table of batch results
  summary.cols <- matrix(NA, nrow=nrow(x), ncol=rowfuns.count.picked ) # columns with summary stats summarizing all the rows

cat('\n str(summary.rows) \n')
print(str(summary.rows))
cat('\n str(summary.cols)\n')
print(str(summary.cols))
cat('\n\n')
  summary.rows.names<- vector()
  summary.cols.names<- vector()


  # don't summarize character columns like name of site
  charcol <- sapply(x, class)=='character'

  for (i in 1:colfuns.count.picked) {
    fnum <- which(colfun.picked)[i]
    
    cat('\n\n')
    cat('fnum ', fnum, ' and colfuname[fnum] is ', colfuname[fnum],'\n' )
    print('str(colfun[[fnum]](x[ , !charcol]) )'); str(colfun[[fnum]](x[ , !charcol]) )
    print('class(colfun[[fnum]](x[ , !charcol]) )'); print( class(colfun[[fnum]](x[ , !charcol]) ))
    cat('\n\n')
    print('str(summary.rows[i, ][  !charcol])'); str(summary.rows[i, ][ !charcol])
    cat('\n\n')
    
    summary.rows[i, ][  !charcol] <- as.vector( colfun[[fnum]](x[ , !charcol]) )  # don't pass parameters since they are variables available in this memory space? like na.rm, threshold, probs, etc.

    # error/warning: number to replace is not multiple of replacement length
    print('now summary.rows[i, ] all cols is '); print(summary.rows[i, ])

    summary.rows.names[i] <- colfuname[fnum]

    # do.call(f, list(x)) # was old code
    # could this have the wrong # of elements if na.rm=TRUE and it somehow doesn't return NA for one of the columns??
  }

  print(rowfuns.count.picked)

  for (i in 1:rowfuns.count.picked) {
    fnum <- which(rowfun.picked)[i]
    
    print('fnum ');print(fnum); print(' and rowfuname '); print(rowfuname[fnum])
    print('str(rowfun[[fnum]](x) )'); str(rowfun[[fnum]](x) )
    print('')
    print('str(summary.cols[ , i])'); str(summary.cols[ , i])
    
    summary.cols[ , i] <- as.vector( rowfun[[fnum]](x) ) # don't pass parameters since they are variables available in this memory space? like na.rm, threshold, probs, etc.
    summary.cols.names[ i] <- rowfuname[fnum]

  }
  mylist <- list(rows=summary.rows, rownames=summary.rows.names, cols=summary.cols, colnames=summary.cols.names)
  return(mylist)

# str(fulltable)
# 'data.frame':  42 obs. of  179 variables:
# $ OBJECTID                                     : int  1 2 3 4 5 6 7 8 9 10 ...
# $ FACID                                        : chr  "110,000,743,704.000000000000000" "110,000,597,729.000000000000000" "110,000,521,221.000000000000000" "110,000,432,489.000000000000000" ...
# $ name                                         : chr  "EASTMAN CHEMICAL CO TEXAS OPERATIONS" "Ash Grove Cement Company" "Clean Harbors El Dorado LLC" "Safety-Kleen Systems Inc. - Dolton Recycle Center" ...
# $ lat                                          : num  32.4 33.7 33.2 41.6 41.8 ...
# $ lon                                          : num  -94.7 -94.4 -92.6 -87.6 -87.7 ...
# $ pop                                         *: chr  "7,946" "1,487" "14,003" "106,245" ...
# $ radius.miles                                *: chr  "3 miles" "3 miles" "3 miles" "3 miles" ...
# $ ST                                           : chr  "TX" "AR" "AR" "IL" ...
# $ statename                                    : chr  "Texas" "Arkansas" "Arkansas" "Illinois" ...
# $ REGION                                       : int  6 6 6 5 5 5 5 5 5 7 ...
# $ state.pctile.proximity.tsdf                 * : chr  "97" "98" "99" "96" ...
# $ region.pctile.EJ.DISPARITY.traffic.score.eo * : chr  "74" "30" "76" "93" ...
# $ state.pctile.pm                             * : chr  "44" "29" "15" "85" ...
# $ region.pctile.EJ.DISPARITY.cancer.eo        * : chr  "75" "35" "69" "94" ...
# $ state.pctile.EJ.DISPARITY.dpm.eo            * : chr  "61" "49" "84" "88" ...
# $ us.avg.VSI.eo                               ** : chr  "35%" "35%" "35%" "35%" ...
# $ proximity.rmp                               * : chr  "1.2" "0.038" "1" "1.2" ...
# $ region.avg.pm                                : num  9.44 9.44 9.44 13.3 13.3 13.3 13.3 13.3 13.3 11.1 ...
# $ region.avg.pctlths                          ** : chr  "19%" "19%" "19%" "12%" ...
# $ region.avg.dpm                               : num  0.733 0.733 0.733 0.712 0.712 0.712 0.712 0.712 0.712 0.741 ...
# $ pctover64                                   ** : chr  "13%" "18%" "16%" "10%" ...
# $ us.avg.proximity.tsdf                        : num  0.054 0.054 0.054 0.054 0.054 0.054 0.054 0.054 0.054 0.054 ...
# $ region.pctile.pctpre1960                    * : chr  "74" "69" "85" "66" ...
# $ region.pctile.proximity.rmp                 * : chr  "92" "5" "89" "94" ...
# $ state.pctile.dpm                            * : chr  "37" "36" "67" "73" ...
# $ resp                                        * : chr  "1.5" "0.76" "1.8" "2.1" ...
# $ region.pctile.VSI.eo                        * : chr  "72" "33" "68" "92" ...
# $ pctlths                                     ** : chr  "23%" "14%" "27%" "16%" ...
# $ us.avg.traffic.score                         : int  110 110 110 110 110 110 110 110 110 110 ...
# $ state.pctile.neuro                          * : chr  "99" "13" "89" "94" ...
# $ pctile.EJ.DISPARITY.proximity.npl.eo        * : chr  "95" "51" "89" "92" ...
# $ state.avg.VSI.eo                            ** : chr  "47%" "34%" "34%" "34%" ...
# $ state.avg.pctmin                            ** : chr  "55%" "26%" "26%" "36%" ...
# $ state.avg.pctlths                           ** : chr  "20%" "17%" "17%" "14%" ...
# $ state.pctile.EJ.DISPARITY.resp.eo           * : chr  "66" "54" "87" "87" ...
# $ pctile.pm                                   * : chr  "27" "27" "24" "95" ...
# $ VSI.eo                                      ** : chr  "61%" "29%" "56%" "70%" ...
# $ pctile.neuro                                * : chr  "92" "4" "61" "96" ...
# $ pctunder5                                   ** : chr  "7%" "3%" "7%" "6%" ...
# $ pctpre1960                                   : chr  "0.27" "0.22" "0.45" "0.51" ...
# $ region.pctile.proximity.npl                  : chr  "97" "41" "95" "86" ...
# $ state.pctile.resp                            : chr  "54" "26" "92" "67" ...
# $ state.pctile.o3                              : chr  "51" "60" "1" "60" ...
# $ pctile.EJ.DISPARITY.pm.eo                    : chr  "77" "53" "72" "91" ...
# $ state.pctile.pctlths                         : chr  "64" "43" "82" "68" ...
# $ pctile.dpm                                   : chr  "49" "12" "31" "81" ...
# $ state.pctile.pctlowinc                       : chr  "70" "48" "73" "76" ...
# $ proximity.npl                                : chr  "0.29" "0.024" "0.22" "0.13" ...
# $ region.pctile.pctmin                         : chr  "69" "18" "61" "95" ...
# $ state.avg.traffic.score                      : int  91 64 64 69 69 24 24 24 24 38 ...
# $ region.pctile.EJ.DISPARITY.proximity.tsdf.eo : chr  "96" "7" "99" "97" ...
# $ proximity.tsdf                               : chr  "0.33" "0.33" "2.4" "0.13" ...
# $ pctile.EJ.DISPARITY.cancer.eo                : chr  "80" "52" "76" "86" ...
# $ neuro                                        : chr  "0.12" "0.023" "0.057" "0.16" ...
# $ state.avg.dpm                                : num  0.913 0.245 0.245 0.968 0.968 0.341 0.341 0.341 0.341 0.343 ...
# $ pctlowinc                                    : chr  "52%" "41%" "54%" "46%" ...
# $ pctile.EJ.DISPARITY.proximity.rmp.eo         : chr  "95" "56" "92" "96" ...
# $ pctile.o3                                    : chr  "34" "37" "14" "30" ...
# $ state.avg.o3                                 : num  42.9 44.5 44.5 42.8 42.8 47.2 47.2 47.2 47.2 45.2 ...
# $ region.avg.resp                              : num  1.4 1.4 1.4 1.5 1.5 1.5 1.5 1.5 1.5 1.4 ...
# $ state.avg.resp                               : num  1.5 1.1 1.1 1.8 1.8 1.1 1.1 1.1 1.1 0.99 ...
# $ us.avg.dpm                                   : num  0.824 0.824 0.824 0.824 0.824 0.824 0.824 0.824 0.824 0.824 ...
# $ pctile.VSI.eo                                : chr  "83" "50" "79" "89" ...
# $ pctile.proximity.rmp                         : chr  "95" "8" "93" "95" ...
# $ pctmin                                       : chr  "69%" "17%" "58%" "94%" ...
# $ pctile.cancer                                : chr  "72" "33" "81" "71" ...
# $ region.pctile.o3                             : chr  "47" "53" "19" "35" ...
# $ state.pctile.VSI.eo                          : chr  "68" "50" "84" "88" ...
# $ us.avg.proximity.rmp                         : num  0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 0.31 ...
# $ region.pctile.EJ.DISPARITY.pctpre1960.eo     : chr  "84" "18" "81" "93" ...
# $ region.avg.neuro                             : num  0.043 0.043 0.043 0.067 0.067 0.067 0.067 0.067 0.067 0.052 ...
# $ us.avg.pctpre1960                            : num  0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 0.3 ...
# $ state.pctile.proximity.rmp                   : chr  "91" "17" "91" "92" ...
# $ region.avg.proximity.rmp                     : num  0.42 0.42 0.42 0.33 0.33 0.33 0.33 0.33 0.33 0.41 ...
# $ dpm                                          : chr  "0.478" "0.0875" "0.24" "1.35" ...
# $ region.pctile.pctlingiso                     : chr  "66" "36" "39" "67" ...
# $ region.avg.traffic.score                     : int  81 81 81 69 69 69 69 69 69 61 ...
# $ region.avg.pctpre1960                        : num  0.18 0.18 0.18 0.39 0.39 0.39 0.39 0.39 0.39 0.35 ...
# $ region.pctile.pctover64                      : chr  "63" "83" "77" "38" ...
# $ pctile.EJ.DISPARITY.neuro.eo                 : chr  "90" "55" "75" "96" ...
# $ region.pctile.cancer                         : chr  "87" "39" "95" "80" ...
# $ region.pctile.proximity.npdes                : chr  "73" "5" "96" "88" ...
# $ us.avg.cancer                                : int  49 49 49 49 49 49 49 49 49 49 ...
# $ pctile.pctmin                                : chr  "79" "38" "74" "93" ...
# $ state.avg.proximity.tsdf                     : num  0.073 0.046 0.046 0.037 0.037 0.042 0.042 0.042 0.042 0.063 ...
# $ state.avg.proximity.npl                      : num  0.067 0.033 0.033 0.069 0.069 0.1 0.1 0.1 0.1 0.063 ...
# $ region.avg.pctover64                         : chr  "11%" "11%" "11%" "13%" ...
# $ state.pctile.pctmin                          : chr  "62" "51" "86" "91" ...
# $ state.pctile.EJ.DISPARITY.proximity.tsdf.eo  : chr  "94" "4" "99" "98" ...
# $ state.pctile.EJ.DISPARITY.proximity.rmp.eo   : chr  "86" "56" "92" "96" ...
# $ us.avg.pm                                    : num  10.7 10.7 10.7 10.7 10.7 10.7 10.7 10.7 10.7 10.7 ...
# $ region.avg.proximity.tsdf                    : num  0.062 0.062 0.062 0.051 0.051 0.051 0.051 0.051 0.051 0.038 ...
# $ state.avg.proximity.rmp                      : num  0.47 0.33 0.33 0.43 0.43 0.35 0.35 0.35 0.35 0.43 ...
# $ pctlingiso                                   : chr  "6%" "0%" "1%" "1%" ...
# $ state.pctile.traffic.score                   : chr  "60" "44" "79" "77" ...
# $ state.pctile.EJ.DISPARITY.pm.eo              : chr  "61" "53" "80" "89" ...
# $ state.avg.pctpre1960                         : num  0.17 0.17 0.17 0.43 0.43 0.35 0.35 0.35 0.35 0.36 ...
# $ region.pctile.EJ.DISPARITY.neuro.eo          : chr  "92" "38" "68" "98" ...
# $ state.avg.pctlingiso                         : chr  "9%" "2%" "2%" "6%" ...
# [list output truncated]
# > 
}

